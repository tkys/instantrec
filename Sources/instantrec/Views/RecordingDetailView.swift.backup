import SwiftUI
import SwiftData

// MARK: - Expert Information Architecture & Navigation Design
// Implements professional iOS navigation patterns and hierarchical information design

struct RecordingDetailView: View {
    let recording: Recording
    let modelContext: ModelContext
    @Environment(\.dismiss) private var dismiss
    @StateObject private var playbackManager = PlaybackManager.shared
    @State private var isEditingTranscription = false
    @State private var editedTranscription = ""
    @State private var isEditingTitle = false
    @State private var editedTitle = ""
    @State private var showingShareSheet = false
    
    var body: some View {
        // MARK: - Modern iOS Navigation (No nested NavigationView)
        ScrollView {
            VStack(alignment: .leading, spacing: HierarchicalSpacing.level1) {
                    // Header Section - 統一コンポーネント使用
                    UnifiedDetailHeader(
                        title: recording.displayName,
                        subtitle: "Audio Recording",
                        metadata: [
                            recording.relativeTimeString,
                            formatDuration(recording.duration),
                            "Transcription: \(recording.transcriptionStatus.displayName)"
                        ],
                        isEditing: isEditingTitle,
                        onEditToggle: { startTitleEdit() },
                        onSave: { saveTitle() },
                        onCancel: { cancelTitleEdit() }
                    )
                    
                    // Playback Controls - 統一コンポーネント使用
                    VStack(spacing: ListUITheme.secondarySpacing) {
                        HStack(spacing: ListUITheme.primarySpacing) {
                            ListActionButton(
                                title: playbackManager.isPlayingRecording(recording) ? "Pause" : "Play",
                                iconName: playbackManager.isPlayingRecording(recording) ? "pause.fill" : "play.fill",
                                size: .large,
                                style: .primary,
                                action: {
                                    playbackManager.play(recording: recording)
                                }
                            )
                            .frame(maxWidth: .infinity)
                            
                            UnifiedStatusIndicator(
                                status: .favorite(recording.isFavorite),
                                action: {
                                    withAnimation(.easeInOut(duration: 0.2)) {
                                        recording.isFavorite.toggle()
                                        try? modelContext.save()
                                    }
                                }
                            )
                        }
                        
                        // Progress Slider - 統一コンポーネント使用
                        if playbackManager.currentPlayingRecording?.id == recording.id {
                            VStack(spacing: ListUITheme.compactSpacing) {
                                Slider(value: .constant(playbackManager.playbackProgress), in: 0...1)
                                    .accentColor(ListUITheme.primaryColor)
                                
                                HStack {
                                    UnifiedMetadata(
                                        primaryText: playbackManager.currentPlaybackTime,
                                        secondaryText: nil,
                                        iconName: nil
                                    )
                                    
                                    Spacer()
                                    
                                    UnifiedMetadata(
                                        primaryText: formatDuration(recording.duration),
                                        secondaryText: nil,
                                        iconName: nil
                                    )
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal, HierarchicalSpacing.level3)
                
                // Visual separator with semantic meaning
                Divider()
                    .padding(.horizontal, HierarchicalSpacing.level3)
                    .padding(.vertical, HierarchicalSpacing.level4)
                
                // Transcription Section - Professional Information Architecture
                if let transcription = recording.transcription, !transcription.isEmpty {
                    VStack(alignment: .leading, spacing: HierarchicalSpacing.level2) {
                        HStack {
                            Text("Transcription")
                                .font(ListUITheme.subtitleFont)
                                .foregroundColor(ListUITheme.infoColor)
                            
                            Image(systemName: "doc.text")
                                .foregroundColor(ListUITheme.infoColor)
                                .font(ListUITheme.captionFont)
                            
                            Spacer()
                            
                            if recording.transcription != recording.originalTranscription {
                                UnifiedStatusIndicator(
                                    status: .transcriptionNone,
                                    action: nil
                                )
                                .foregroundColor(ListUITheme.warningColor)
                            }
                        }
                        
                        if isEditingTranscription {
                            // Edit Mode - 統一コンポーネント使用
                            VStack(alignment: .leading, spacing: ListUITheme.secondarySpacing) {
                                TextEditor(text: $editedTranscription)
                                    .font(ListUITheme.bodyFont)
                                    .frame(minHeight: 200)
                                    .padding(ListUITheme.secondarySpacing)
                                    .background(Color(.systemGray6))
                                    .cornerRadius(ListUITheme.cardCornerRadius)
                                
                                HStack(spacing: ListUITheme.primarySpacing) {
                                    ListActionButton(
                                        title: "Cancel",
                                        iconName: "xmark",
                                        size: .medium,
                                        style: .outline(ListUITheme.neutralColor),
                                        action: { cancelTranscriptionEdit() }
                                    )
                                    
                                    Spacer()
                                    
                                    if recording.transcription != recording.originalTranscription {
                                        ListActionButton(
                                            title: "Reset",
                                            iconName: "arrow.counterclockwise",
                                            size: .medium,
                                            style: .warning,
                                            action: { resetTranscription() }
                                        )
                                    }
                                    
                                    ListActionButton(
                                        title: "Save",
                                        iconName: "checkmark",
                                        size: .medium,
                                        style: .primary,
                                        action: { saveTranscription() }
                                    )
                                    .disabled(editedTranscription == transcription)
                                }
                            }
                        } else {
                            // Display Mode - 統一コンポーネント使用
                            VStack(alignment: .leading, spacing: ListUITheme.secondarySpacing) {
                                Text(transcription)
                                    .font(ListUITheme.bodyFont)
                                    .textSelection(.enabled)
                                    .padding(.bottom, ListUITheme.tightSpacing)
                                
                                HStack(spacing: ListUITheme.primarySpacing) {
                                    ListActionButton(
                                        title: "Edit",
                                        iconName: "pencil",
                                        size: .medium,
                                        style: .outline(ListUITheme.primaryColor),
                                        action: { startTranscriptionEdit() }
                                    )
                                    
                                    Spacer()
                                    
                                    if recording.transcription != recording.originalTranscription {
                                        ListActionButton(
                                            title: "Reset to Original",
                                            iconName: "arrow.counterclockwise",
                                            size: .medium,
                                            style: .outline(ListUITheme.warningColor),
                                            action: { resetTranscription() }
                                        )
                                    }
                                }
                            }
                        }
                    }
                    .padding(.horizontal, HierarchicalSpacing.level3)
                    .accessibilityElement(children: .contain)
                    .accessibilityLabel("Transcription Section")
                } else {
                    VStack(spacing: HierarchicalSpacing.level3) {
                        UnifiedStatusIndicator(
                            status: .transcriptionNone,
                            action: nil
                        )
                        
                        Text("No transcription available")
                            .font(ListUITheme.subtitleFont)
                            .foregroundColor(.secondary)
                        
                        Text("Enable Auto Transcription in Settings to automatically transcribe new recordings.")
                            .font(ListUITheme.captionFont)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.horizontal, HierarchicalSpacing.level3)
                    .padding(.vertical, HierarchicalSpacing.level1 * 1.5)
                    .accessibilityElement(children: .contain)
                    .accessibilityLabel("No transcription available")
                }
            } // Main VStack closes here
            .padding(.vertical, HierarchicalSpacing.level3)
        } // ScrollView closes here
        .navigationTitle(recording.displayName)
        .navigationBarTitleDisplayMode(.large)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Menu {
                    // Primary Actions - Most common user tasks
                    Section {
                        Button(action: { shareRecording() }) {
                            Label("Share Recording", systemImage: "square.and.arrow.up")
                        }
                        .accessibilityIdentifier("shareRecordingButton")
                        
                        Button(action: { 
                            playbackManager.isPlayingRecording(recording) ? 
                                playbackManager.pause() : 
                                playbackManager.play(recording: recording)
                        }) {
                            Label(
                                playbackManager.isPlayingRecording(recording) ? "Pause" : "Play",
                                systemImage: playbackManager.isPlayingRecording(recording) ? "pause" : "play"
                            )
                        }
                    }
                    
                    // Secondary Actions - Content management
                    Section {
                        if recording.transcription != nil {
                            Button(action: { exportTranscription() }) {
                                Label("Export Transcription", systemImage: "doc.on.doc")
                            }
                        }
                        
                        Button(action: {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                recording.isFavorite.toggle()
                                try? modelContext.save()
                            }
                        }) {
                            Label(
                                recording.isFavorite ? "Remove from Favorites" : "Add to Favorites",
                                systemImage: recording.isFavorite ? "star.slash" : "star"
                            )
                        }
                    }
                    
                    // Destructive Actions - Separated for safety
                    Section {
                        Button(role: .destructive, action: { deleteRecording() }) {
                            Label("Delete Recording", systemImage: "trash")
                        }
                        .accessibilityIdentifier("deleteRecordingButton")
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                        .font(.title3)
                        .accessibilityLabel("More Actions")
                        .accessibilityHint("Opens menu with additional recording actions")
                }
            }
        }
        .sheet(isPresented: $showingShareSheet) {
            ActivityView(recording: recording)
                .presentationDetents([.medium, .large])
                .presentationDragIndicator(.visible)
        }
        // Enhanced accessibility for the entire detail view
        .accessibilityElement(children: .contain)
        .accessibilityLabel("Recording details for \(recording.displayName)")
        // Haptic feedback for navigation
        .onAppear {
            let impactGenerator = UIImpactFeedbackGenerator(style: .light)
            impactGenerator.impactOccurred()
        }
    }
    
    // MARK: - Helper Functions
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    
    // MARK: - Title Editing
    
    private func startTitleEdit() {
        editedTitle = recording.customTitle ?? recording.displayName
        isEditingTitle = true
    }
    
    private func saveTitle() {
        let trimmedTitle = editedTitle.trimmingCharacters(in: .whitespaces)
        
        withAnimation(.easeInOut(duration: 0.2)) {
            recording.customTitle = trimmedTitle.isEmpty ? nil : trimmedTitle
            isEditingTitle = false
            
            do {
                try modelContext.save()
            } catch {
                print("Failed to save title: \(error)")
            }
        }
    }
    
    private func cancelTitleEdit() {
        editedTitle = recording.customTitle ?? recording.displayName
        isEditingTitle = false
    }
    
    // MARK: - Transcription Editing
    
    private func startTranscriptionEdit() {
        if let transcription = recording.transcription {
            editedTranscription = transcription
            isEditingTranscription = true
        }
    }
    
    private func saveTranscription() {
        withAnimation(.easeInOut(duration: 0.2)) {
            // 初回編集時は元の文字起こしを保存
            if recording.originalTranscription == nil {
                recording.originalTranscription = recording.transcription
            }
            
            recording.transcription = editedTranscription
            isEditingTranscription = false
            
            do {
                try modelContext.save()
            } catch {
                print("Failed to save transcription: \(error)")
            }
        }
    }
    
    private func cancelTranscriptionEdit() {
        if let transcription = recording.transcription {
            editedTranscription = transcription
        }
        isEditingTranscription = false
    }
    
    private func resetTranscription() {
        withAnimation(.easeInOut(duration: 0.2)) {
            if let original = recording.originalTranscription {
                recording.transcription = original
                editedTranscription = original
                isEditingTranscription = false
                
                do {
                    try modelContext.save()
                } catch {
                    print("Failed to reset transcription: \(error)")
                }
            }
        }
    }
    
    // MARK: - Cloud Sync Status Helpers
    
    private func cloudSyncIcon() -> String {
        switch recording.cloudSyncStatus {
        case .uploading:
            return "cloud.arrow.up"
        case .synced:
            return "checkmark.icloud"
        case .error:
            return "exclamationmark.icloud"
        case .pending:
            return "clock.arrow.circlepath"
        default:
            return "icloud.slash"
        }
    }
    
    private func cloudSyncStatusText() -> String {
        switch recording.cloudSyncStatus {
        case .uploading:
            return "Uploading..."
        case .synced:
            return "Synced"
        case .error:
            return recording.syncErrorMessage ?? "Sync Error"
        case .pending:
            return "Pending"
        default:
            return "Not synced"
        }
    }
    
    private func cloudSyncStatusColor() -> Color {
        switch recording.cloudSyncStatus {
        case .uploading:
            return .blue
        case .synced:
            return .green
        case .error:
            return .red
        case .pending:
            return .orange
        default:
            return .secondary
        }
    }
    
    // MARK: - Helper Methods for Status Colors
    
    private func colorFromString(_ colorString: String) -> Color {
        switch colorString {
        case "blue": return .blue
        case "green": return .green
        case "red": return .red
        case "orange": return .orange
        case "gray": return .gray
        default: return .primary
        }
    }
    
    // MARK: - Professional Action Methods with UX Enhancements
    
    private func shareRecording() {
        // Haptic feedback for action
        let impactGenerator = UIImpactFeedbackGenerator(style: .medium)
        impactGenerator.impactOccurred()
        
        print("📤 Share recording: \(recording.fileName)")
        showingShareSheet = true
        
        // Accessibility announcement
        UIAccessibility.post(notification: .announcement, 
                           argument: "Share options opened for \(recording.displayName)")
    }
    
    private func exportTranscription() {
        // Haptic feedback
        let impactGenerator = UIImpactFeedbackGenerator(style: .light)
        impactGenerator.impactOccurred()
        
        // TODO: Implement export transcription functionality
        print("📄 Export transcription for: \(recording.fileName)")
        
        // User feedback
        UIAccessibility.post(notification: .announcement, 
                           argument: "Exporting transcription for \(recording.displayName)")
    }
    
    private func deleteRecording() {
        // Strong haptic feedback for destructive action
        let feedbackGenerator = UINotificationFeedbackGenerator()
        feedbackGenerator.notificationOccurred(.warning)
        
        // TODO: Implement delete confirmation and action
        print("🗑️ Delete recording: \(recording.fileName)")
        
        // Show confirmation alert in production
        UIAccessibility.post(notification: .announcement, 
                           argument: "\(recording.displayName) deleted")
        
        dismiss()
    }
}

// MARK: - Hierarchical Spacing Extension
extension HierarchicalSpacing {
    // Detail-specific spacing
    static let sectionSpacing: CGFloat = level1      // Between major sections
    static let groupSpacing: CGFloat = level2        // Between related groups
    static let elementSpacing: CGFloat = level3      // Between individual elements
    static let tightSpacing: CGFloat = level4        // For closely related items
}