import SwiftUI

struct SegmentedRecordingView: View {
    @StateObject private var segmentedService = SegmentedRecordingService()
    @Environment(\.dismiss) private var dismiss
    
    @State private var baseName = ""
    @State private var showingMergeProgress = false
    @State private var mergeProgress = 0.0
    @State private var mergedFileURL: URL?
    @State private var errorMessage: String?
    @State private var showingError = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 24) {
                
                // „Éò„ÉÉ„ÉÄ„ÉºÊÉÖÂ†±
                VStack(spacing: 12) {
                    Text("üé¨ „Çª„Ç∞„É°„É≥„ÉàÈå≤Èü≥")
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text("15ÂàÜ„Åî„Å®„Å´Ëá™ÂãïÂàÜÂâ≤„Åó„ÄÅÊúÄÂæå„Å´ÁµêÂêà„Åó„Åæ„Åô")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                
                // Èå≤Èü≥Áä∂ÊÖãË°®Á§∫
                if segmentedService.isRecording {
                    recordingStatusView
                } else {
                    recordingSetupView
                }
                
                // „Çª„Ç∞„É°„É≥„ÉàÊÉÖÂ†±Ë°®Á§∫
                if !segmentedService.getSegmentInfos().isEmpty {
                    segmentInfoView
                }
                
                Spacer()
                
                // Âà∂Âæ°„Éú„Çø„É≥
                controlButtonsView
                
            }
            .padding()
            .navigationTitle("„Çª„Ç∞„É°„É≥„ÉàÈå≤Èü≥")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Èñâ„Åò„Çã") {
                        dismiss()
                    }
                }
            }
            .alert("„Ç®„É©„Éº", isPresented: $showingError) {
                Button("OK") { }
            } message: {
                Text(errorMessage ?? "‰∏çÊòé„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü")
            }
            .sheet(isPresented: $showingMergeProgress) {
                mergeProgressView
            }
        }
    }
    
    // MARK: - Èå≤Èü≥„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó„Éì„É•„Éº
    
    private var recordingSetupView: some View {
        VStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 8) {
                Text("Èå≤Èü≥„Éï„Ç°„Ç§„É´Âêç")
                    .font(.subheadline)
                    .fontWeight(.medium)
                
                TextField("‰æã: meeting-20250127", text: $baseName)
                    .textFieldStyle(.roundedBorder)
                    .autocapitalization(.none)
                    .disableAutocorrection(true)
            }
            
            VStack(alignment: .leading, spacing: 8) {
                Text("„Çª„Ç∞„É°„É≥„ÉàÈå≤Èü≥„ÅÆÁâπÂæ¥")
                    .font(.subheadline)
                    .fontWeight(.medium)
                
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Image(systemName: "timer")
                            .foregroundColor(.blue)
                        Text("15ÂàÜ„Åî„Å®„Å´Ëá™ÂãïÂàÜÂâ≤")
                    }
                    .font(.caption)
                    
                    HStack {
                        Image(systemName: "shield.checkered")
                            .foregroundColor(.green)
                        Text("‰∏≠Êñ≠„Åã„Çâ„ÅÆËá™ÂãïÂæ©Â∏∞")
                    }
                    .font(.caption)
                    
                    HStack {
                        Image(systemName: "link")
                            .foregroundColor(.orange)
                        Text("Èå≤Èü≥ÂÆå‰∫ÜÊôÇ„Å´Ëá™ÂãïÁµêÂêà")
                    }
                    .font(.caption)
                }
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(8)
        }
    }
    
    // MARK: - Èå≤Èü≥Áä∂ÊÖã„Éì„É•„Éº
    
    private var recordingStatusView: some View {
        VStack(spacing: 16) {
            // Èå≤Èü≥„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº
            HStack {
                Circle()
                    .fill(Color.red)
                    .frame(width: 12, height: 12)
                    .opacity(0.8)
                    .scaleEffect(1.2)
                    .animation(.easeInOut(duration: 1).repeatForever(), value: segmentedService.isRecording)
                
                Text("Èå≤Èü≥‰∏≠")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            
            // ÊôÇÈñìË°®Á§∫
            VStack(spacing: 8) {
                Text(formatDuration(segmentedService.totalDuration))
                    .font(.title)
                    .fontWeight(.bold)
                    .monospacedDigit()
                
                Text("Á∑èÈå≤Èü≥ÊôÇÈñì")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            // „Çª„Ç∞„É°„É≥„ÉàÊÉÖÂ†±
            HStack(spacing: 32) {
                VStack {
                    Text("\(segmentedService.currentSegmentIndex)")
                        .font(.title2)
                        .fontWeight(.semibold)
                    Text("ÁèæÂú®„Çª„Ç∞„É°„É≥„Éà")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                VStack {
                    Text("\(segmentedService.segmentCount)")
                        .font(.title2)
                        .fontWeight(.semibold)
                    Text("Á∑è„Çª„Ç∞„É°„É≥„ÉàÊï∞")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding()
            .background(Color(UIColor.secondarySystemBackground))
            .cornerRadius(12)
        }
    }
    
    // MARK: - „Çª„Ç∞„É°„É≥„ÉàÊÉÖÂ†±„Éì„É•„Éº
    
    private var segmentInfoView: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("„Çª„Ç∞„É°„É≥„Éà‰∏ÄË¶ß")
                .font(.headline)
                .fontWeight(.semibold)
            
            ScrollView {
                LazyVStack(spacing: 8) {
                    ForEach(Array(segmentedService.getSegmentInfos().enumerated()), id: \.offset) { index, segmentInfo in
                        segmentRow(segmentInfo: segmentInfo)
                    }
                }
            }
            .frame(maxHeight: 200)
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
    }
    
    private func segmentRow(segmentInfo: SegmentedRecordingService.SegmentInfo) -> some View {
        HStack {
            Text("Seg \(segmentInfo.index + 1)")
                .font(.caption)
                .fontWeight(.medium)
                .frame(width: 50, alignment: .leading)
            
            Text(formatDuration(segmentInfo.duration))
                .font(.caption)
                .monospacedDigit()
                .frame(width: 60, alignment: .leading)
            
            Text("\(segmentInfo.fileSize / 1024)KB")
                .font(.caption)
                .foregroundColor(.secondary)
                .frame(width: 60, alignment: .leading)
            
            Spacer()
            
            Text(formatTime(segmentInfo.startTime))
                .font(.caption2)
                .foregroundColor(.secondary)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
    }
    
    // MARK: - Âà∂Âæ°„Éú„Çø„É≥
    
    private var controlButtonsView: some View {
        VStack(spacing: 16) {
            if segmentedService.isRecording {
                // Èå≤Èü≥ÂÅúÊ≠¢„Éú„Çø„É≥
                Button {
                    stopRecording()
                } label: {
                    HStack {
                        Image(systemName: "stop.fill")
                        Text("Èå≤Èü≥ÂÅúÊ≠¢")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.red)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                
            } else {
                // Èå≤Èü≥ÈñãÂßã„Éú„Çø„É≥
                Button {
                    startRecording()
                } label: {
                    HStack {
                        Image(systemName: "record.circle.fill")
                        Text("Èå≤Èü≥ÈñãÂßã")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(baseName.isEmpty ? Color.gray : Color.red)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(baseName.isEmpty)
                
                // „Çª„Ç∞„É°„É≥„ÉàÁµêÂêà„Éú„Çø„É≥Ôºà„Çª„Ç∞„É°„É≥„Éà„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
                if !segmentedService.getSegmentInfos().isEmpty {
                    Button {
                        mergeSegments()
                    } label: {
                        HStack {
                            Image(systemName: "link")
                            Text("„Çª„Ç∞„É°„É≥„ÉàÁµêÂêà")
                        }
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                }
            }
        }
    }
    
    // MARK: - ÁµêÂêàÈÄ≤Êçó„Éì„É•„Éº
    
    private var mergeProgressView: some View {
        VStack(spacing: 24) {
            Text("„Çª„Ç∞„É°„É≥„ÉàÁµêÂêà‰∏≠...")
                .font(.headline)
                .fontWeight(.semibold)
            
            ProgressView(value: mergeProgress)
                .progressViewStyle(LinearProgressViewStyle())
            
            Text("\(Int(mergeProgress * 100))%")
                .font(.caption)
                .foregroundColor(.secondary)
            
            if let mergedURL = mergedFileURL {
                VStack(spacing: 8) {
                    Text("‚úÖ ÁµêÂêàÂÆå‰∫Ü")
                        .font(.headline)
                        .foregroundColor(.green)
                    
                    Text(mergedURL.lastPathComponent)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding()
    }
    
    // MARK: - „Ç¢„ÇØ„Ç∑„Éß„É≥
    
    private func startRecording() {
        guard !baseName.isEmpty else { return }
        
        // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        Task {
            let audioService = AudioService()
            let granted = await audioService.requestMicrophonePermission()
            
            await MainActor.run {
                if granted {
                    let success = segmentedService.startSegmentedRecording(baseName: baseName)
                    if !success {
                        errorMessage = "Èå≤Èü≥„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
                        showingError = true
                    }
                } else {
                    errorMessage = "„Éû„Ç§„ÇØ„ÅÆÊ®©Èôê„ÅåÂøÖË¶Å„Åß„Åô„ÄÇË®≠ÂÆö„Ç¢„Éó„É™„ÅßÊ®©Èôê„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    showingError = true
                }
            }
        }
    }
    
    private func stopRecording() {
        let segmentURLs = segmentedService.stopSegmentedRecording()
        print("üõë Recording stopped. Segments: \(segmentURLs.count)")
    }
    
    private func mergeSegments() {
        showingMergeProgress = true
        mergeProgress = 0.0
        
        Task {
            do {
                let outputFileName = "\(baseName)-merged-\(formatTimestamp()).m4a"
                
                // ÈÄ≤Êçó„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
                for i in 1...10 {
                    try await Task.sleep(nanoseconds: 100_000_000) // 0.1Áßí
                    await MainActor.run {
                        mergeProgress = Double(i) / 10.0
                    }
                }
                
                let mergedURL = try await segmentedService.mergeSegments(outputFileName: outputFileName)
                
                await MainActor.run {
                    mergedFileURL = mergedURL
                    mergeProgress = 1.0
                }
                
                // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                segmentedService.cleanupSegments()
                
            } catch {
                await MainActor.run {
                    showingMergeProgress = false
                    errorMessage = "„Çª„Ç∞„É°„É≥„ÉàÁµêÂêà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error.localizedDescription)"
                    showingError = true
                }
            }
        }
    }
    
    // MARK: - „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = Int(duration) % 3600 / 60
        let seconds = Int(duration) % 60
        
        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, seconds)
        } else {
            return String(format: "%d:%02d", minutes, seconds)
        }
    }
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func formatTimestamp() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd-HHmmss"
        return formatter.string(from: Date())
    }
}